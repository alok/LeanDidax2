/-
  Logging utilities for LeanDidax.
  This module provides simple logging capabilities
  for differentiable computations.
-/

import LeanDidax2.Basic
import LeanDidax2.Monadic
import LeanDidax2.Utils

namespace LeanDidax2

namespace WriterTransformer

/--
  LoggedOperation holds the result of an operation along with its logs.
-/
structure LoggedOperation (α : Type) where
  /-- Result of the operation -/
  result : α
  /-- Logs generated by the operation -/
  logs : Array String := #[]
  deriving Inhabited

/--
  Add a message to a logged operation.
-/
def addLog {α : Type} (op : LoggedOperation α) (message : String) : LoggedOperation α :=
  { op with logs := op.logs.push message }

/--
  Log a binary operation.
-/
def loggedOp (opName : String) (a b : Value Float) (op : Value Float → Value Float → Value Float) :
    Monadic.DiffM (LoggedOperation (Value Float)) := do
  let result := op a b
  let logs := #[s!"Operation: {opName}", s!"Result: {result.primal}"]
  pure { result := result, logs := logs }

/--
  Execute a differentiable computation with logging and perform an IO action.
-/
def runDiffWithLogsIO {α β : Type}
  (computation : Monadic.DiffM (LoggedOperation α))
  (action : α → Array String → IO β) : IO β := do
  let diffResult := Monadic.runDiff computation
  let logged := diffResult.primal
  action logged.result logged.logs

/--
  Filter logs to only show entries matching a predicate.
-/
def filterLogs (logs : Array String) (predicate : String → Bool) : Array String :=
  logs.filter predicate

/--
  Get logs for operations only.
-/
def getOperationLogs (logs : Array String) : Array String :=
  filterLogs logs (fun entry => entry.startsWith "Operation:")

/--
  Format logs as a string with each entry on a new line.
-/
def formatLogs (logs : Array String) : String :=
  logs.foldl (fun acc entry => acc ++ entry ++ "\n") ""

/--
  Format logs with timestamps (simulation).
-/
def formatLogsWithTimestamps (logs : Array String) : String :=
  let simulate := fun (i : Nat) => s!"T+{i * 10}ms"
  logs.mapIdx (fun i entry => s!"[{simulate i}] {entry}")
    |>.foldl (fun acc entry => acc ++ entry ++ "\n") ""

end WriterTransformer

end LeanDidax2
